/*
Package wd GENERATED BY gengo:runtimedoc 
DON'T EDIT THIS FILE
*/
package wd

// nolint:deadcode,unused
func runtimeDoc(v any, names ...string) ([]string, bool) {
	if c, ok := v.(interface {
		RuntimeDoc(names ...string) ([]string, bool)
	}); ok {
		return c.RuntimeDoc(names...)
	}
	return nil, false
}

func (v Dir) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "WorkDir":
			return []string{
				"current work dir",
			}, true
		case "Path":
			return []string{
				"path related from current work dir",
			}, true

		}

		return nil, false
	}
	return []string{}, true
}

func (v Local) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "Task":
			return []string{}, true
		case "Source":
			return []string{
				"related dir on the root of project",
			}, true
		case "WorkDir":
			return []string{
				"the local workdir",
			}, true

		}
		if doc, ok := runtimeDoc(v.Task, names...); ok {
			return doc, ok
		}

		return nil, false
	}
	return []string{
		"Local",
		"create a local workdir",
	}, true
}

func (v Platform) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "OS":
			return []string{}, true
		case "Architecture":
			return []string{}, true

		}

		return nil, false
	}
	return []string{}, true
}

func (v Rel) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "Task":
			return []string{}, true
		case "BaseDir":
			return []string{}, true
		case "TargetDir":
			return []string{}, true
		case "Path":
			return []string{}, true

		}
		if doc, ok := runtimeDoc(v.Task, names...); ok {
			return doc, ok
		}

		return nil, false
	}
	return []string{
		"Rel to get related path between two dirs",
	}, true
}

func (v Release) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "Name":
			return []string{
				"OS name",
			}, true
		case "Version":
			return []string{
				"OS Version",
			}, true
		case "ID":
			return []string{
				"OS id, like `ubuntu` `windows`",
			}, true
		case "IDLike":
			return []string{
				"if os is based on some upstream",
				"like debian when id is `ubuntu`",
			}, true

		}

		return nil, false
	}
	return []string{}, true
}

func (v SSH) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "Task":
			return []string{}, true
		case "Address":
			return []string{
				"ssh address",
			}, true
		case "HostKey":
			return []string{
				"ssh hostKey",
			}, true
		case "IdentityFile":
			return []string{
				"ssh identity file",
			}, true
		case "Port":
			return []string{
				"ssh port",
			}, true
		case "User":
			return []string{
				"ssh user",
			}, true
		case "WorkDir":
			return []string{
				"the workdir from ssh",
			}, true

		}
		if doc, ok := runtimeDoc(v.Task, names...); ok {
			return doc, ok
		}

		return nil, false
	}
	return []string{
		"SSH",
		"create ssh work dir for remote executing",
	}, true
}

func (v SSHFromConfig) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "Task":
			return []string{}, true
		case "Config":
			return []string{
				"path to ssh config",
			}, true
		case "HostKey":
			return []string{
				"host key of ssh config",
			}, true
		case "WorkDir":
			return []string{
				"the workdir from ssh",
			}, true

		}
		if doc, ok := runtimeDoc(v.Task, names...); ok {
			return doc, ok
		}

		return nil, false
	}
	return []string{
		"SSHFromConfig",
		"create ssh work dir for remote executing",
	}, true
}

func (v Su) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "Task":
			return []string{}, true
		case "Cwd":
			return []string{
				"current workdir",
			}, true
		case "User":
			return []string{
				"switched user",
			}, true
		case "WorkDir":
			return []string{
				"switched workdir with the switched user",
			}, true

		}
		if doc, ok := runtimeDoc(v.Task, names...); ok {
			return doc, ok
		}

		return nil, false
	}
	return []string{
		"Su",
		"switch user",
	}, true
}

func (v Sub) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "Task":
			return []string{}, true
		case "Cwd":
			return []string{
				"current workdir",
			}, true
		case "Path":
			return []string{
				"related path from current workdir",
			}, true
		case "WorkDir":
			return []string{
				"new workdir",
			}, true

		}
		if doc, ok := runtimeDoc(v.Task, names...); ok {
			return doc, ok
		}

		return nil, false
	}
	return []string{
		"Sub",
		"create new work dir base on current work dir",
	}, true
}

func (v SysInfo) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "Task":
			return []string{}, true
		case "Cwd":
			return []string{
				"current workdir",
			}, true
		case "Home":
			return []string{
				"home",
			}, true
		case "Release":
			return []string{
				"os release info",
			}, true
		case "Platform":
			return []string{
				"os platform",
			}, true

		}
		if doc, ok := runtimeDoc(v.Task, names...); ok {
			return doc, ok
		}

		return nil, false
	}
	return []string{
		"SysInfo",
		"get sys info of current work dir",
	}, true
}

func (v Temp) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "Task":
			return []string{}, true
		case "ID":
			return []string{
				"related dir on the root of project",
			}, true
		case "WorkDir":
			return []string{
				"the tmp workdir",
			}, true

		}
		if doc, ok := runtimeDoc(v.Task, names...); ok {
			return doc, ok
		}

		return nil, false
	}
	return []string{
		"Tm",
		"create a tmp workdir",
	}, true
}

func (v WorkDir) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {

		}

		return nil, false
	}
	return []string{}, true
}
