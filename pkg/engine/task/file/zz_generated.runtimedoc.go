/*
Package file GENERATED BY gengo:runtimedoc 
DON'T EDIT THIS FILE
*/
package file

// nolint:deadcode,unused
func runtimeDoc(v any, names ...string) ([]string, bool) {
	if c, ok := v.(interface {
		RuntimeDoc(names ...string) ([]string, bool)
	}); ok {
		return c.RuntimeDoc(names...)
	}
	return nil, false
}

func (v Exists) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "CurrentWorkDir":
			return []string{}, true
		case "Path":
			return []string{
				"path",
			}, true
		case "ExistsResult":
			return []string{}, true

		}
		if doc, ok := runtimeDoc(v.CurrentWorkDir, names...); ok {
			return doc, ok
		}
		if doc, ok := runtimeDoc(v.ExistsResult, names...); ok {
			return doc, ok
		}

		return nil, false
	}
	return []string{
		"Exists to check path exists",
	}, true
}

func (v ExistsResult) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "Result":
			return []string{}, true
		case "IsDir":
			return []string{}, true
		case "Mode":
			return []string{}, true
		case "Size":
			return []string{}, true

		}
		if doc, ok := runtimeDoc(v.Result, names...); ok {
			return doc, ok
		}

		return nil, false
	}
	return []string{}, true
}

func (v File) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "Cwd":
			return []string{
				"current work dir",
			}, true
		case "Filename":
			return []string{
				"filename related from current work dir",
			}, true

		}

		return nil, false
	}
	return []string{}, true
}

func (v ReadAsString) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "CurrentWorkDir":
			return []string{}, true
		case "Filename":
			return []string{
				"filename",
			}, true
		case "ReadAsStringResult":
			return []string{}, true

		}
		if doc, ok := runtimeDoc(v.CurrentWorkDir, names...); ok {
			return doc, ok
		}
		if doc, ok := runtimeDoc(v.ReadAsStringResult, names...); ok {
			return doc, ok
		}

		return nil, false
	}
	return []string{
		"ReadAsString read file as string",
	}, true
}

func (v ReadAsStringResult) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "Result":
			return []string{}, true
		case "Contents":
			return []string{}, true

		}
		if doc, ok := runtimeDoc(v.Result, names...); ok {
			return doc, ok
		}

		return nil, false
	}
	return []string{}, true
}

func (v ReadAsTable) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "CurrentWorkDir":
			return []string{}, true
		case "Filename":
			return []string{
				"filename",
			}, true
		case "With":
			return []string{
				"options",
			}, true
		case "ReadAsTableResult":
			return []string{
				"file contents",
			}, true

		}
		if doc, ok := runtimeDoc(v.CurrentWorkDir, names...); ok {
			return doc, ok
		}
		if doc, ok := runtimeDoc(v.ReadAsTableResult, names...); ok {
			return doc, ok
		}

		return nil, false
	}
	return []string{
		"ReadAsTable file read as table",
	}, true
}

func (v ReadAsTableOption) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "StrictColNum":
			return []string{
				"strict column num",
			}, true

		}

		return nil, false
	}
	return []string{}, true
}

func (v ReadAsTableResult) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "Result":
			return []string{}, true
		case "Data":
			return []string{
				"file contents",
			}, true

		}
		if doc, ok := runtimeDoc(v.Result, names...); ok {
			return doc, ok
		}

		return nil, false
	}
	return []string{}, true
}

func (v ReadFromYAML) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "CurrentWorkDir":
			return []string{}, true
		case "Filename":
			return []string{
				"filename",
			}, true
		case "ReadFromYAMLResult":
			return []string{
				"data",
			}, true

		}
		if doc, ok := runtimeDoc(v.CurrentWorkDir, names...); ok {
			return doc, ok
		}
		if doc, ok := runtimeDoc(v.ReadFromYAMLResult, names...); ok {
			return doc, ok
		}

		return nil, false
	}
	return []string{
		"ReadFromYAML read and parse yaml",
	}, true
}

func (v ReadFromYAMLResult) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "Result":
			return []string{}, true
		case "Data":
			return []string{}, true

		}
		if doc, ok := runtimeDoc(v.Result, names...); ok {
			return doc, ok
		}

		return nil, false
	}
	return []string{}, true
}

func (v StringOrFile) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "File":
			return []string{}, true
		case "String":
			return []string{}, true

		}

		return nil, false
	}
	return []string{}, true
}

func (v Sync) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "Source":
			return []string{
				"source file",
			}, true
		case "With":
			return []string{
				"sync option",
			}, true
		case "Dest":
			return []string{
				"dest fie",
			}, true
		case "WrittenFileResult":
			return []string{}, true

		}
		if doc, ok := runtimeDoc(v.WrittenFileResult, names...); ok {
			return doc, ok
		}

		return nil, false
	}
	return []string{
		"Sync file to contents",
	}, true
}

func (v SyncOption) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "MaxConcurrent":
			return []string{
				"once maxConcurrent larger than 1,",
				"file will split to chunk for partially read and write when syncing",
			}, true

		}

		return nil, false
	}
	return []string{}, true
}

func (v Write) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "CurrentWorkDir":
			return []string{}, true
		case "Filename":
			return []string{
				"filename",
			}, true
		case "Contents":
			return []string{
				"file contents",
			}, true
		case "WrittenFileResult":
			return []string{
				"the written file",
				"just group cwd and filename",
			}, true

		}
		if doc, ok := runtimeDoc(v.CurrentWorkDir, names...); ok {
			return doc, ok
		}
		if doc, ok := runtimeDoc(v.WrittenFileResult, names...); ok {
			return doc, ok
		}

		return nil, false
	}
	return []string{
		"Write file with contents",
	}, true
}

func (v WriteAsJSON) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "CurrentWorkDir":
			return []string{}, true
		case "Filename":
			return []string{
				"filename",
			}, true
		case "Data":
			return []string{
				"data could convert to json",
			}, true
		case "WrittenFileResult":
			return []string{}, true

		}
		if doc, ok := runtimeDoc(v.CurrentWorkDir, names...); ok {
			return doc, ok
		}
		if doc, ok := runtimeDoc(v.WrittenFileResult, names...); ok {
			return doc, ok
		}

		return nil, false
	}
	return []string{
		"WriteAsJSON read and parse json",
	}, true
}

func (v WriteAsYAML) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "CurrentWorkDir":
			return []string{}, true
		case "Filename":
			return []string{
				"filename",
			}, true
		case "Data":
			return []string{
				"data could convert to yaml",
			}, true
		case "WrittenFileResult":
			return []string{}, true

		}
		if doc, ok := runtimeDoc(v.CurrentWorkDir, names...); ok {
			return doc, ok
		}
		if doc, ok := runtimeDoc(v.WrittenFileResult, names...); ok {
			return doc, ok
		}

		return nil, false
	}
	return []string{
		"WriteAsYAML read and parse yaml",
	}, true
}

func (v WrittenFileResult) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "Result":
			return []string{}, true
		case "File":
			return []string{}, true

		}
		if doc, ok := runtimeDoc(v.Result, names...); ok {
			return doc, ok
		}

		return nil, false
	}
	return []string{}, true
}
