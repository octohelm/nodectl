/*
Package file GENERATED BY gengo:runtimedoc
DON'T EDIT THIS FILE
*/
package file

// nolint:deadcode,unused
func runtimeDoc(v any, names ...string) ([]string, bool) {
	if c, ok := v.(interface {
		RuntimeDoc(names ...string) ([]string, bool)
	}); ok {
		return c.RuntimeDoc(names...)
	}
	return nil, false
}

func (v File) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "Cwd":
			return []string{
				"current work dir",
			}, true
		case "Filename":
			return []string{
				"filename related from current work dir",
			}, true

		}

		return nil, false
	}
	return []string{}, true
}

func (v ReadAsString) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "CurrentWorkDir":
			return []string{}, true
		case "Filename":
			return []string{
				"filename",
			}, true
		case "Contents":
			return []string{}, true

		}
		if doc, ok := runtimeDoc(v.CurrentWorkDir, names...); ok {
			return doc, ok
		}

		return nil, false
	}
	return []string{
		"ReadAsString read file as string",
	}, true
}

func (v ReadAsTable) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "CurrentWorkDir":
			return []string{}, true
		case "Filename":
			return []string{
				"filename",
			}, true
		case "With":
			return []string{
				"options",
			}, true
		case "Data":
			return []string{
				"file contents",
			}, true

		}
		if doc, ok := runtimeDoc(v.CurrentWorkDir, names...); ok {
			return doc, ok
		}

		return nil, false
	}
	return []string{
		"ReadAsTable file read as table",
	}, true
}

func (v ReadAsTableOption) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "StrictColNum":
			return []string{
				"strict column num",
			}, true

		}

		return nil, false
	}
	return []string{}, true
}

func (v StringOrFile) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "File":
			return []string{}, true
		case "String":
			return []string{}, true

		}

		return nil, false
	}
	return []string{}, true
}

func (v Sync) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "Source":
			return []string{
				"source file",
			}, true
		case "With":
			return []string{
				"sync option",
			}, true
		case "Dest":
			return []string{
				"dest fie",
			}, true

		}

		return nil, false
	}
	return []string{
		"Sync file to contents",
	}, true
}

func (v SyncOption) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "maxConcurrent":
			return []string{
				"when maxConcurrent larger than 1,",
				"file will split to chunk for partially read and write when syncing",
			}, true

		}

		return nil, false
	}
	return []string{}, true
}

func (v Write) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "CurrentWorkDir":
			return []string{}, true
		case "Filename":
			return []string{
				"filename",
			}, true
		case "Contents":
			return []string{
				"file contents",
			}, true
		case "Output":
			return []string{
				"the written file",
				"just group cwd and filename",
			}, true

		}
		if doc, ok := runtimeDoc(v.CurrentWorkDir, names...); ok {
			return doc, ok
		}

		return nil, false
	}
	return []string{
		"Write file with contents",
	}, true
}
